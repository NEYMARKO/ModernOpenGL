#include "MeshLoader.h"

MeshLoader::MeshLoader(const char* filePath)
{
    std::ifstream file;
    file.open(filePath);
    if (!file.fail())
    {
        std::vector<glm::vec3> normalVectors;
        ReadFile(file, normalVectors);
        CalculateScalingFactor();
    }
    else
    {
        std::cout << "There was a problem with opening the file";
    }
}

void MeshLoader::ReadFile(std::ifstream& file, std::vector<glm::vec3>& normalVectors)
{
    std::string line;
    while (std::getline(file, line))
    {
        SplitLine(line, normalVectors);
    }
    return;
}


void MeshLoader::SplitLine(std::string_view line, std::vector<glm::vec3>& normalVectors)
{
    size_t pos = line.find(' ');
    std::string_view state = line.substr(0, pos);
    line.remove_prefix(pos + 1);

    constexpr size_t bufferSize = 64;  // Adjust this based on your data
    char buffer[bufferSize];

    size_t posInBuffer = 0;
    size_t posInLine = 0;

    Vertex v;
    short pos = 0;
    glm::vec3 vec3(1.0f, 1.0f, 1.0f);

    if (state[0] != 'f')
    {
        while (posInLine < line.size())
        {
            if (line[posInLine] == ' ')
            {
                buffer[posInBuffer] = '\0';

                float coordinate = std::stof(buffer);
                ProcessCoordinate(state, coordinate, pos, vec3, v, normalVectors);
                pos++;
                posInBuffer = 0;
            }
            else
            {
                buffer[posInBuffer++] = line[posInLine];
            }

            ++posInLine;
        }

        // Process the last word in the buffer
        if (posInBuffer > 0)
        {
            buffer[posInBuffer] = '\0';

            float coordinate = std::stof(buffer);
            ProcessCoordinate(state, coordinate, pos, vec3, v, normalVectors);
        }
        return;
    }

    else if (state == "f ")
    {
        while (std::getline(lineStream, word, ' '))
        {
            size_t delimiterPos = word.find("//");
            std::string indexString = word.substr(0, delimiterPos);
            std::string normalIndexString = word.substr(delimiterPos + 2, word.length());

            unsigned int index = std::stoul(indexString) - 1;
            unsigned int normalPos = std::stoul(normalIndexString) - 1;
            this->vertices[index].normal = normalVectors[normalPos];
            this->indices.push_back(index);
        }
        return;
    }
    return;
}

void MeshLoader::ProcessCoordinate(std::string_view state, float coordinate, short position, glm::vec3& vector, Vertex& v, std::vector<glm::vec3>& normalVectors)
{
    switch (state.back())
    {
    case 'v':
        if (coordinate < this->minExtremes[position])
        {
            this->minExtremes[position] = coordinate;
        }
        else if (coordinate > this->maxExtremes[position])
        {
            this->maxExtremes[position] = coordinate;
        }
        vector[position] = coordinate;
        if (position == 2)
        {
            v.position = vector;
            this->vertices.emplace_back(v);
        }
        break;

    case 'n':
        vector[position] = coordinate;

        if (position == 2)
        {
            normalVectors.emplace_back(vector);
        }
        break;

    default:
        break;
    }
}
void MeshLoader::CalculateScalingFactor()
{
    float xmin = minExtremes[0];
    float ymin = minExtremes[1];
    float zmin = minExtremes[2];
    float xmax = maxExtremes[0];
    float ymax = maxExtremes[1];
    float zmax = maxExtremes[2];
    float firstComparison = std::max(1 / (xmax - xmin), 1 / (ymax - ymin));
    this->scalingFactor = std::max(firstComparison, 1 / (zmax - zmin));
}

MeshLoader::~MeshLoader()
{
    //std::cout << "Deleted loader" << std::endl;
}